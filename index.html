<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris</title>
    <style>
      :root {
        --primary: lightskyblue;
        --secondary: plum;
        --background: #121212;
        --grid-color: rgba(255, 255, 255, 0.1);
        --text: #ffffff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background-color: var(--background);
        color: var(--text);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: auto;
        position: relative;
      }

      .background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          45deg,
          #121212 25%,
          #1a1a1a 25%,
          #1a1a1a 50%,
          #121212 50%,
          #121212 75%,
          #1a1a1a 75%
        );
        background-size: 20px 20px;
        opacity: 0.5;
        z-index: -1;
      }

      .container {
        display: flex;
        gap: 5px;
        padding: 10px;
        border-radius: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        box-shadow: 0 0 20px plum;
        position: relative;
        overflow: hidden;
      }

      .container::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: conic-gradient(
          transparent,
          var(--primary),
          transparent 30%
        );
        animation: rotate 10s linear infinite;
        z-index: -1;
      }

      .container::after {
        content: "";
        position: absolute;
        inset: 4px;
        background: var(--background);
        border-radius: 8px;
        z-index: -1;
      }

      @keyframes rotate {
        100% {
          transform: rotate(1turn);
        }
      }

      .game-area {
        position: relative;
        gap: 5px;
      }

      #game-board {
        width: 300px;
        height: 600px;
        border: 2px solid var(--primary);
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(20, 1fr);
        gap: 2px;
        background-color: rgba(0, 0, 0, 0.8);
        position: relative;
        overflow: hidden;
      }

      #game-board::before {
        content: "";
        position: absolute;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
            to right,
            transparent,
            transparent calc(10% - 1px),
            var(--grid-color) calc(10% - 1px),
            var(--grid-color) 10%
          ),
          repeating-linear-gradient(
            to bottom,
            transparent,
            transparent calc(5% - 1px),
            var(--grid-color) calc(5% - 1px),
            var(--grid-color) 5%
          );
        pointer-events: none;
      }

      .cell {
        position: relative;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 5px;
        width: 200px;
      }

      .preview-box,
      .hold-box {
        background-color: rgba(0, 0, 0, 0.6);
        border: 2px solid var(--primary);
        border-radius: 5px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 5px;
      }

      .preview-title,
      .hold-title {
        font-size: 0.75rem;
        margin-bottom: 5px;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--primary);
        text-shadow: 0 0 5px var(--primary);
      }

      #next-piece,
      #hold-piece {
        width: 120px;
        height: 120px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(4, 1fr);
        gap: 2px;
      }

      .stats {
        background-color: rgba(0, 0, 0, 0.6);
        border: 2px solid var(--primary);
        border-radius: 5px;
        padding: 10px;
        font-size: 0.75rem;
      }

      .stat {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5x;
      }

      .stat-value {
        font-weight: bold;
        color: var(--primary);
      }

      .controls {
        background-color: rgba(0, 0, 0, 0.6);
        border: 2px solid var(--primary);
        border-radius: 5px;
        padding: 10px;
        font-size: 0.75rem;
      }

      .control-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
      }

      .key {
        display: inline-block;
        padding: 5px 10px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        font-family: monospace;
        color: var(--primary);
        min-width: 30px;
        text-align: center;
      }

      .buttons {
        display: flex;
        gap: 5px;
        justify-content: left;
        margin-top: 5px;
        margin-bottom: 5px;
      }

      button {
        background-color: var(--primary);
        color: black;
        border: none;
        padding: 7px 7px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
        text-transform: uppercase;
      }

      button:hover {
        background-color: var(--secondary);
        color: black;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px plum;
      }

      .i-piece {
        background-color: #00ffff;
        box-shadow: 0 0 5px #00ffff;
      }
      .j-piece {
        background-color: #0000ff;
        box-shadow: 0 0 5px #0000ff;
      }
      .l-piece {
        background-color: #ff7f00;
        box-shadow: 0 0 5px #ff7f00;
      }
      .o-piece {
        background-color: #ffff00;
        box-shadow: 0 0 5px #ffff00;
      }
      .s-piece {
        background-color: #00ff00;
        box-shadow: 0 0 5px #00ff00;
      }
      .t-piece {
        background-color: #800080;
        box-shadow: 0 0 5px #800080;
      }
      .z-piece {
        background-color: #ff0000;
        box-shadow: 0 0 5px #ff0000;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      .overlay.active {
        opacity: 1;
        pointer-events: all;
      }

      .overlay h2 {
        font-size: 1rem;
        margin-bottom: 20px;
        color: var(--primary);
        text-shadow: 0 0 10px var(--primary);
      }

      #settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      #settings-modal.active {
        opacity: 1;
        pointer-events: all;
      }

      .settings-content {
        width: 500px;
        background-color: var(--background);
        border: 2px solid var(--primary);
        border-radius: 10px;
        padding: 10px;
        position: relative;
      }

      .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        color: var(--text);
        font-size: 1rem;
        cursor: pointer;
      }

      .keybind-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .keybind-btn {
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--primary);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 4px;
        cursor: pointer;
        min-width: 80px;
        text-align: center;
      }

      .keybind-btn.listening {
        background-color: var(--primary);
        color: black;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 lightskyblue;
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 255, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 255, 255, 0);
        }
      }

      .particle {
        position: absolute;
        pointer-events: none;
        border-radius: 50%;
        z-index: 100;
      }

      @keyframes levelUp {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.5);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .level-up {
        animation: levelUp 0.5s ease-in-out;
      }

      .ghost {
        opacity: 0.3;
        border: 2px dashed white;
        background-color: transparent !important;
        box-shadow: none !important;
      }

      .touch-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        margin-top: 2px;
      }

      .touch-row {
        display: flex;
        justify-content: center;
        gap: 2px;
      }

      .ctrl-btn {
        background-color: rgba(255, 255, 255, 0.1);
        box-shadow: 0 5px 15px rgba(255, 0, 255, 0.4);
        border: 2px solid var(--primary);
        color: var(--primary);
        font-size: 1.2rem;
        font-weight: bold;
        align-items: center;
        padding: 8px 8px;
        border-radius: 2px;
        cursor: pointer;
        user-select: none;
        min-width: 60px;
        min-height: 30px;
      }

      .ctrl-btn:active {
        background-color: var(--primary);
        color: black;
      }

      @media (max-width: 768px) {
        body {
          overflow-y: auto;
          padding: 10px;
        }

        .container {
          flex-direction: column;
          align-items: center;
          gap: 5px;
        }

        #game-board {
          width: min(60vw, 300px);
          height: calc(min(60vw, 300px) * 2);
          gap: 5px;
        }

        .piece-boxes {
          display: flex;
          gap: 5px;
          width: 100%;
          justify-content: center;
        }

        .side-panel {
          width: 100%;
          max-width: 320px;
        }

        #next-piece,
        #hold-piece {
          width: min(20vw, 100px);
          height: min(20vw, 100px);
        }

        .settings-content {
          width: min(90vw, 500px);
        }

        .preview-box,
        .hold-box {
          flex: 1;
          min-width: 0;
        }

        .side-panel {
          display: flex;
          flex-wrap: wrap;
          gap: 5px;
        }

        .stats,
        .controls {
          flex-basis: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="background"></div>
    <div class="container">
      <div class="game-area">
        <div class="buttons">
          <button id="pause-btn">Pause</button>
          <button id="settings-btn-alt">Settings</button>
        </div>

        <div id="game-board"></div>

        <div class="touch-controls">
          <div class="touch-row">
            <button class="ctrl-btn" id="btn-left">←</button>
            <button class="ctrl-btn" id="btn-rotate">⟳</button>
            <button class="ctrl-btn" id="btn-right">→</button>
          </div>
          <div class="touch-row">
            <button class="ctrl-btn" id="btn-soft">↓</button>
            <button class="ctrl-btn" id="btn-hard">⤓</button>
            <button class="ctrl-btn" id="btn-hold">H</button>
          </div>
        </div>

        <div id="game-over" class="overlay">
          <h2>GAME OVER</h2>
          <p>Your score: <span id="final-score">0</span></p>
          <div class="buttons">
            <button id="restart-btn">Play Again</button>
          </div>
        </div>

        <div id="pause-overlay" class="overlay">
          <h2>PAUSED</h2>
          <div class="buttons">
            <button id="resume-btn">Resume</button>
            <button id="settings-btn">Settings</button>
          </div>
        </div>
      </div>

      <div class="side-panel">
        <div class="piece-boxes">
          <div class="preview-box">
            <div class="preview-title">Next</div>
            <div id="next-piece"></div>
          </div>
          <div class="hold-box">
            <div class="hold-title">Hold (C)</div>
            <div id="hold-piece"></div>
          </div>
        </div>

        <div class="stats">
          <div class="stat">
            <span>Score:</span>
            <span id="score" class="stat-value">0</span>
          </div>
          <div class="stat">
            <span>Level:</span>
            <span id="level" class="stat-value">1</span>
          </div>
          <div class="stat">
            <span>Lines:</span>
            <span id="lines" class="stat-value">0</span>
          </div>
        </div>

        <div class="controls">
          <div class="control-row">
            <span>Move Left:</span>
            <span id="move-left-key" class="key">←</span>
          </div>
          <div class="control-row">
            <span>Move Right:</span>
            <span id="move-right-key" class="key">→</span>
          </div>
          <div class="control-row">
            <span>Rotate:</span>
            <span id="rotate-key" class="key">↑</span>
          </div>
          <div class="control-row">
            <span>Soft Drop:</span>
            <span id="soft-drop-key" class="key">↓</span>
          </div>
          <div class="control-row">
            <span>Hard Drop:</span>
            <span id="hard-drop-key" class="key">Space</span>
          </div>
          <div class="control-row">
            <span>Hold Piece:</span>
            <span id="hold-key" class="key">C</span>
          </div>
          <div class="control-row">
            <span>Pause:</span>
            <span id="pause-key" class="key">P</span>
          </div>
        </div>
      </div>
    </div>

    <div id="settings-modal">
      <div class="settings-content">
        <button class="close-btn">&times;</button>
        <h2>Controls Settings</h2>
        <div class="keybind-container">
          <div class="keybind-row">
            <span>Move Left</span>
            <button class="keybind-btn" data-action="moveLeft">←</button>
          </div>
          <div class="keybind-row">
            <span>Move Right</span>
            <button class="keybind-btn" data-action="moveRight">→</button>
          </div>
          <div class="keybind-row">
            <span>Rotate</span>
            <button class="keybind-btn" data-action="rotate">↑</button>
          </div>
          <div class="keybind-row">
            <span>Soft Drop</span>
            <button class="keybind-btn" data-action="softDrop">↓</button>
          </div>
          <div class="keybind-row">
            <span>Hard Drop</span>
            <button class="keybind-btn" data-action="hardDrop">Space</button>
          </div>
          <div class="keybind-row">
            <span>Hold Piece</span>
            <button class="keybind-btn" data-action="hold">C</button>
          </div>
          <div class="keybind-row">
            <span>Pause</span>
            <button class="keybind-btn" data-action="pause">P</button>
          </div>
        </div>
        <div class="buttons">
          <button id="save-settings">Save</button>
          <button id="reset-settings">Reset to Default</button>
        </div>
      </div>
    </div>
  </body>
</html>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const BOARD_SIZE = BOARD_WIDTH * BOARD_HEIGHT;
    const EMPTY_COLOR = "";

    const gameBoard = document.getElementById("game-board");
    const nextPieceDisplay = document.getElementById("next-piece");
    const holdPieceDisplay = document.getElementById("hold-piece");
    const scoreDisplay = document.getElementById("score");
    const levelDisplay = document.getElementById("level");
    const linesDisplay = document.getElementById("lines");
    const pauseBtn = document.getElementById("pause-btn");
    const settingsBtn = document.getElementById("settings-btn");
    const settingsBtnAlt = document.getElementById("settings-btn-alt");
    const pauseOverlay = document.getElementById("pause-overlay");
    const resumeBtn = document.getElementById("resume-btn");
    const gameOverOverlay = document.getElementById("game-over");
    const finalScoreDisplay = document.getElementById("final-score");
    const restartBtn = document.getElementById("restart-btn");
    const settingsModal = document.getElementById("settings-modal");
    const saveSettingsBtn = document.getElementById("save-settings");
    const resetSettingsBtn = document.getElementById("reset-settings");
    const closeSettingsBtn = document.querySelector(".close-btn");
    const keybindButtons = document.querySelectorAll(".keybind-btn");

    let controls = {
      moveLeft: "ArrowLeft",
      moveRight: "ArrowRight",
      rotate: "ArrowUp",
      softDrop: "ArrowDown",
      hardDrop: " ",
      hold: "c",
      pause: "p",
    };

    let board = Array(BOARD_SIZE).fill(EMPTY_COLOR);
    let currentPiece = null;
    let nextPiece = null;
    let holdPiece = null;
    let hasHeld = false;
    let gameInterval = null;
    let isPaused = false;
    let isGameOver = false;
    let score = 0;
    let level = 1;
    let lines = 0;
    let dropSpeed = 1000;

    const TETROMINOS = {
      I: {
        shape: [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
        ],
        className: "i-piece",
      },
      J: {
        shape: [
          [1, 0, 0],
          [1, 1, 1],
          [0, 0, 0],
        ],
        className: "j-piece",
      },
      L: {
        shape: [
          [0, 0, 1],
          [1, 1, 1],
          [0, 0, 0],
        ],
        className: "l-piece",
      },
      O: {
        shape: [
          [1, 1],
          [1, 1],
        ],
        className: "o-piece",
      },
      S: {
        shape: [
          [0, 1, 1],
          [1, 1, 0],
          [0, 0, 0],
        ],
        className: "s-piece",
      },
      T: {
        shape: [
          [0, 1, 0],
          [1, 1, 1],
          [0, 0, 0],
        ],
        className: "t-piece",
      },
      Z: {
        shape: [
          [1, 1, 0],
          [0, 1, 1],
          [0, 0, 0],
        ],
        className: "z-piece",
      },
    };

    function init() {
      for (let i = 0; i < BOARD_SIZE; i++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        gameBoard.appendChild(cell);
      }

      for (let i = 0; i < 16; i++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        nextPieceDisplay.appendChild(cell);
      }

      for (let i = 0; i < 16; i++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        holdPieceDisplay.appendChild(cell);
      }

      const savedControls = localStorage.getItem("tetrisControls");
      if (savedControls) {
        controls = JSON.parse(savedControls);
        updateControlsDisplay();
      }

      newGame();

      document.addEventListener("keydown", handleKeyPress);
      pauseBtn.addEventListener("click", togglePause);
      resumeBtn.addEventListener("click", togglePause);
      restartBtn.addEventListener("click", newGame);

      settingsBtn.addEventListener("click", openSettings);
      settingsBtnAlt.addEventListener("click", openSettings);
      closeSettingsBtn.addEventListener("click", closeSettings);
      saveSettingsBtn.addEventListener("click", saveSettings);
      resetSettingsBtn.addEventListener("click", resetSettings);

      document.getElementById("btn-left").addEventListener("click", moveLeft);
      document.getElementById("btn-right").addEventListener("click", moveRight);
      document.getElementById("btn-rotate").addEventListener("click", rotate);
      document.getElementById("btn-soft").addEventListener("click", moveDown);
      document.getElementById("btn-hard").addEventListener("click", hardDrop);
      document
        .getElementById("btn-hold")
        .addEventListener("click", holdCurrentPiece);

      keybindButtons.forEach((btn) => {
        btn.addEventListener("click", startRebinding);
      });
    }

    function newGame() {
      board = Array(BOARD_SIZE).fill(EMPTY_COLOR);
      score = 0;
      level = 1;
      lines = 0;
      dropSpeed = 1000;
      holdPiece = null;
      hasHeld = false;
      isPaused = false;
      isGameOver = false;

      scoreDisplay.textContent = score;
      levelDisplay.textContent = level;
      linesDisplay.textContent = lines;

      const cells = gameBoard.querySelectorAll(".cell");
      cells.forEach((cell) => {
        cell.className = "cell";
      });

      gameOverOverlay.classList.remove("active");
      pauseOverlay.classList.remove("active");

      nextPiece = getRandomPiece();
      getNewPiece();

      if (gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(moveDown, dropSpeed);
    }

    function getRandomPiece() {
      const pieces = Object.keys(TETROMINOS);
      const tetromino = pieces[Math.floor(Math.random() * pieces.length)];

      return {
        type: tetromino,
        shape: JSON.parse(JSON.stringify(TETROMINOS[tetromino].shape)),
        className: TETROMINOS[tetromino].className,
        position: {
          x: tetromino === "O" ? 4 : 3,
          y: 0,
        },
        rotation: 0,
      };
    }

    function getNewPiece() {
      currentPiece = nextPiece;
      nextPiece = getRandomPiece();
      hasHeld = false;

      if (!isValidMove(currentPiece)) {
        gameOver();
        return;
      }

      drawPiece();
      drawNextPiece();
      drawGhostPiece();
    }

    function drawPiece() {
      clearPiece();

      const { shape, className, position } = currentPiece;

      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const boardX = position.x + x;
            const boardY = position.y + y;

            if (boardY >= 0) {
              const index = boardY * BOARD_WIDTH + boardX;
              const cell = gameBoard.children[index];
              cell.classList.add(className);
            }
          }
        }
      }
    }

    function drawGhostPiece() {
      const cells = gameBoard.querySelectorAll(".ghost");
      cells.forEach((cell) => cell.classList.remove("ghost"));

      const ghostPiece = JSON.parse(JSON.stringify(currentPiece));

      while (isValidMove(ghostPiece)) {
        ghostPiece.position.y++;
      }

      ghostPiece.position.y--;

      const { shape, position } = ghostPiece;

      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const boardX = position.x + x;
            const boardY = position.y + y;

            if (boardY >= 0) {
              const index = boardY * BOARD_WIDTH + boardX;
              const cell = gameBoard.children[index];

              if (!cell.classList.contains(currentPiece.className)) {
                cell.classList.add("ghost");
              }
            }
          }
        }
      }
    }

    function drawNextPiece() {
      const cells = nextPieceDisplay.querySelectorAll(".cell");
      cells.forEach((cell) => {
        cell.className = "cell";
      });

      const { shape, className } = nextPiece;
      const offsetX = (5 - shape[0].length) / 2;
      const offsetY = (5 - shape.length) / 2;

      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const displayX = Math.floor(offsetX + x);
            const displayY = Math.floor(offsetY + y);
            const index = displayY * 4 + displayX;
            cells[index].classList.add(className);
          }
        }
      }
    }

    function drawHoldPiece() {
      const cells = holdPieceDisplay.querySelectorAll(".cell");
      cells.forEach((cell) => {
        cell.className = "cell";
      });

      if (holdPiece) {
        const { shape, className } = holdPiece;
        const offsetX = (5 - shape[0].length) / 2;
        const offsetY = (5 - shape.length) / 2;

        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              const displayX = Math.floor(offsetX + x);
              const displayY = Math.floor(offsetY + y);
              const index = displayY * 4 + displayX;
              cells[index].classList.add(className);
            }
          }
        }
      }
    }

    function clearPiece() {
      const cells = gameBoard.querySelectorAll(".cell");
      cells.forEach((cell) => {
        if (!cell.classList.contains("locked")) {
          cell.className = "cell";
        }
      });
    }

    function isValidMove(piece) {
      const { shape, position } = piece;

      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const boardX = position.x + x;
            const boardY = position.y + y;

            if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
              return false;
            }

            if (boardY >= 0) {
              const index = boardY * BOARD_WIDTH + boardX;
              const cell = gameBoard.children[index];

              if (cell.classList.contains("locked")) {
                return false;
              }
            }
          }
        }
      }

      return true;
    }

    function lockPiece() {
      const { shape, className, position } = currentPiece;

      for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
          if (shape[y][x]) {
            const boardX = position.x + x;
            const boardY = position.y + y;

            if (boardY >= 0) {
              const index = boardY * BOARD_WIDTH + boardX;
              const cell = gameBoard.children[index];
              cell.classList.add("locked");
            }
          }
        }
      }

      checkLines();

      getNewPiece();

      createParticles();
    }

    function moveDown() {
      if (isPaused || isGameOver) return;

      currentPiece.position.y++;

      if (!isValidMove(currentPiece)) {
        currentPiece.position.y--;
        lockPiece();
      } else {
        drawPiece();
        drawGhostPiece();
      }
    }

    function moveLeft() {
      if (isPaused || isGameOver) return;

      currentPiece.position.x--;

      if (!isValidMove(currentPiece)) {
        currentPiece.position.x++;
      } else {
        drawPiece();
        drawGhostPiece();
      }
    }

    function moveRight() {
      if (isPaused || isGameOver) return;

      currentPiece.position.x++;

      if (!isValidMove(currentPiece)) {
        currentPiece.position.x--;
      } else {
        drawPiece();
        drawGhostPiece();
      }
    }

    function rotate() {
      if (isPaused || isGameOver) return;
      if (currentPiece.type === "O") return;

      const originalPosition = { ...currentPiece.position };
      const originalShape = JSON.parse(JSON.stringify(currentPiece.shape));

      const size = currentPiece.shape.length;
      const newShape = Array(size)
        .fill()
        .map(() => Array(size).fill(0));

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          newShape[x][size - 1 - y] = currentPiece.shape[y][x];
        }
      }

      currentPiece.shape = newShape;

      const kicks = [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: -1 },
        { x: 1, y: -1 },
        { x: -1, y: -1 },
      ];

      let validKick = false;

      for (const kick of kicks) {
        currentPiece.position.x = originalPosition.x + kick.x;
        currentPiece.position.y = originalPosition.y + kick.y;

        if (isValidMove(currentPiece)) {
          validKick = true;
          break;
        }
      }

      if (!validKick) {
        currentPiece.position = { ...originalPosition };
        currentPiece.shape = originalShape;
      } else {
        drawPiece();
        drawGhostPiece();
      }
    }

    function hardDrop() {
      if (isPaused || isGameOver) return;

      while (isValidMove(currentPiece)) {
        currentPiece.position.y++;
      }

      currentPiece.position.y--;

      drawPiece();
      lockPiece();
    }

    function holdCurrentPiece() {
      if (isPaused || isGameOver || hasHeld) return;

      hasHeld = true;
      clearPiece();

      if (holdPiece === null) {
        holdPiece = {
          type: currentPiece.type,
          shape: JSON.parse(
            JSON.stringify(TETROMINOS[currentPiece.type].shape)
          ),
          className: currentPiece.className,
          position: { x: currentPiece.type === "O" ? 4 : 3, y: 0 },
          rotation: 0,
        };
        getNewPiece();
      } else {
        const temp = currentPiece;
        currentPiece = {
          type: holdPiece.type,
          shape: JSON.parse(JSON.stringify(holdPiece.shape)),
          className: holdPiece.className,
          position: { x: holdPiece.type === "O" ? 4 : 3, y: 0 },
          rotation: 0,
        };
        holdPiece = {
          type: temp.type,
          shape: JSON.parse(JSON.stringify(TETROMINOS[temp.type].shape)),
          className: temp.className,
          position: { x: temp.type === "O" ? 4 : 3, y: 0 },
          rotation: 0,
        };
      }

      drawHoldPiece();
      drawPiece();
      drawGhostPiece();
    }

    function checkLines() {
      let linesCleared = 0;

      for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        let isLineComplete = true;

        for (let x = 0; x < BOARD_WIDTH; x++) {
          const index = y * BOARD_WIDTH + x;
          const cell = gameBoard.children[index];

          if (!cell.classList.contains("locked")) {
            isLineComplete = false;
            break;
          }
        }

        if (isLineComplete) {
          linesCleared++;

          for (let x = 0; x < BOARD_WIDTH; x++) {
            const index = y * BOARD_WIDTH + x;
            const cell = gameBoard.children[index];
            cell.className = "cell";

            setTimeout(() => {
              cell.style.backgroundColor = "#FFFFFF";
              setTimeout(() => {
                cell.style.backgroundColor = "";
              }, 50);
            }, x * 20);
          }

          for (let yy = y; yy > 0; yy--) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
              const index = yy * BOARD_WIDTH + x;
              const above = (yy - 1) * BOARD_WIDTH + x;

              const cell = gameBoard.children[index];
              const cellAbove = gameBoard.children[above];

              cell.className = cellAbove.className;
            }
          }

          for (let x = 0; x < BOARD_WIDTH; x++) {
            const cell = gameBoard.children[x];
            cell.className = "cell";
          }

          y++;
        }
      }

      if (linesCleared > 0) {
        updateScore(linesCleared);
      }
    }

    function updateScore(linesCleared) {
      const linePoints = [0, 100, 300, 500, 800];
      const levelMultiplier = level;

      score += linePoints[linesCleared] * levelMultiplier;
      lines += linesCleared;

      const newLevel = Math.floor(lines / 10) + 1;
      if (newLevel > level) {
        level = newLevel;
        levelDisplay.classList.add("level-up");
        setTimeout(() => {
          levelDisplay.classList.remove("level-up");
        }, 500);

        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
        clearInterval(gameInterval);
        gameInterval = setInterval(moveDown, dropSpeed);
      }

      scoreDisplay.textContent = score;
      levelDisplay.textContent = level;
      linesDisplay.textContent = lines;
    }

    function createParticles() {
      if (currentPiece.position.y < 0) return;

      const colors = ["#00ffff", "#ff00ff", "#ffff00", "#00ff00"];

      for (let i = 0; i < 20; i++) {
        const particle = document.createElement("div");
        particle.classList.add("particle");

        const rect = gameBoard.getBoundingClientRect();
        const x = rect.left + currentPiece.position.x * 30 + Math.random() * 60;
        const y = rect.top + currentPiece.position.y * 30 + Math.random() * 60;

        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        particle.style.backgroundColor =
          colors[Math.floor(Math.random() * colors.length)];
        particle.style.width = `${Math.random() * 8 + 2}px`;
        particle.style.height = particle.style.width;

        document.body.appendChild(particle);

        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3 + 1;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        let opacity = 1;

        const animateParticle = () => {
          opacity -= 0.02;
          particle.style.opacity = opacity;
          particle.style.left = `${parseFloat(particle.style.left) + vx}px`;
          particle.style.top = `${parseFloat(particle.style.top) + vy}px`;

          if (opacity > 0) {
            requestAnimationFrame(animateParticle);
          } else {
            particle.remove();
          }
        };

        requestAnimationFrame(animateParticle);
      }
    }

    function gameOver() {
      isGameOver = true;
      clearInterval(gameInterval);

      gameOverOverlay.classList.add("active");
      finalScoreDisplay.textContent = score;
    }

    function togglePause() {
      if (isGameOver) return;

      isPaused = !isPaused;

      if (isPaused) {
        clearInterval(gameInterval);
        pauseOverlay.classList.add("active");
      } else {
        gameInterval = setInterval(moveDown, dropSpeed);
        pauseOverlay.classList.remove("active");
      }
    }

    function handleKeyPress(e) {
      e.preventDefault();

      const key = e.key.toLowerCase();
      const code = e.code;

      if (
        (code === "Space" && controls.hardDrop === " ") ||
        key === controls.hardDrop.toLowerCase()
      ) {
        hardDrop();
      } else if (
        key === controls.moveLeft.toLowerCase() ||
        code === controls.moveLeft
      ) {
        moveLeft();
      } else if (
        key === controls.moveRight.toLowerCase() ||
        code === controls.moveRight
      ) {
        moveRight();
      } else if (
        key === controls.rotate.toLowerCase() ||
        code === controls.rotate
      ) {
        rotate();
      } else if (
        key === controls.softDrop.toLowerCase() ||
        code === controls.softDrop
      ) {
        moveDown();
      } else if (
        key === controls.hold.toLowerCase() ||
        code === controls.hold
      ) {
        holdCurrentPiece();
      } else if (
        key === controls.pause.toLowerCase() ||
        code === controls.pause
      ) {
        togglePause();
      }
    }

    function openSettings() {
      if (!isPaused && !isGameOver) {
        togglePause();
      }

      settingsModal.classList.add("active");

      keybindButtons.forEach((btn) => {
        const action = btn.dataset.action;
        btn.textContent = getKeyDisplay(controls[action]);
      });
    }

    function closeSettings() {
      settingsModal.classList.remove("active");
    }

    function saveSettings() {
      localStorage.setItem("tetrisControls", JSON.stringify(controls));

      updateControlsDisplay();

      closeSettings();
    }

    function resetSettings() {
      controls = {
        moveLeft: "ArrowLeft",
        moveRight: "ArrowRight",
        rotate: "ArrowUp",
        softDrop: "ArrowDown",
        hardDrop: " ",
        hold: "c",
        pause: "p",
      };

      keybindButtons.forEach((btn) => {
        const action = btn.dataset.action;
        btn.textContent = getKeyDisplay(controls[action]);
      });
    }

    function updateControlsDisplay() {
      document.getElementById("move-left-key").textContent = getKeyDisplay(
        controls.moveLeft
      );
      document.getElementById("move-right-key").textContent = getKeyDisplay(
        controls.moveRight
      );
      document.getElementById("rotate-key").textContent = getKeyDisplay(
        controls.rotate
      );
      document.getElementById("soft-drop-key").textContent = getKeyDisplay(
        controls.softDrop
      );
      document.getElementById("hard-drop-key").textContent = getKeyDisplay(
        controls.hardDrop
      );
      document.getElementById("hold-key").textContent = getKeyDisplay(
        controls.hold
      );
      document.getElementById("pause-key").textContent = getKeyDisplay(
        controls.pause
      );
    }

    function getKeyDisplay(key) {
      const specialKeys = {
        " ": "Space",
        ArrowLeft: "←",
        ArrowRight: "→",
        ArrowUp: "↑",
        ArrowDown: "↓",
        Control: "Ctrl",
        Escape: "Esc",
      };

      return specialKeys[key] || key.toUpperCase();
    }

    function startRebinding(e) {
      const btn = e.target;
      const action = btn.dataset.action;

      keybindButtons.forEach((b) => b.classList.remove("listening"));
      btn.classList.add("listening");
      btn.textContent = "Press Key...";

      const keyListener = (e) => {
        e.preventDefault();

        let newKey = e.key;

        if (e.code === "Space") {
          newKey = " ";
        }

        controls[action] = newKey;

        btn.textContent = getKeyDisplay(newKey);
        btn.classList.remove("listening");

        document.removeEventListener("keydown", keyListener);
      };

      document.addEventListener("keydown", keyListener);
    }

    init();
  });
</script>
